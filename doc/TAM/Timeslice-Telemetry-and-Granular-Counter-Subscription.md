#  Timeslice Telemetry and Granular Counter Subscription
-------------------------------------------------------------------------------
 Title       | Timeslice Telemetry and Granular Counter Subscription
-------------|-----------------------------------------------------------------
 Authors     | Jason Bos, Cisco
 Status      | In review
 Type        | Standards track
 Created     | 2023-01-11 - Initial Draft
 SAI-Version | 1.12
-------------------------------------------------------------------------------


## 1.0  Introduction

This spec enhances the existing TAM (Telemetry and Monitoring) spec to address two new features: timeslice telemetry report format, and granular counter subscription.

The intent is that these may be used together to stream reports with a single counter polled at short intervals, but the API design is such that they could be used
independently.

## 2.0 Timeslice Telemetry

The Timeslice telemetry format is an output report format for exporting one or more counters correlated with collection timestamps. The goal is to provide a compact format to observe multiple counters correlated closely correlated in time.

In implementations, the reports may be generated by the datapath, so the exact format of the packet will be vendor-defined. One sample format:

| Node ID | Time-0 timestamp | Time-1 timestamp | Time-2 timestamp | Time-3 timestamp | Time-4 timestamp | Time-5 timestamp |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| Counter-ID 0 | Counter-0 at Time-0 | Counter-0 at Time-1 | Counter-0 at Time-2 | Counter-0 at Time-3 | Counter-0 at Time-4 | Counter-0 at Time-5  |
| Counter-ID 1 | Counter-1 at Time-0 | Counter-1 at Time-1 | Counter-1 at Time-2 | Counter-1 at Time-3 | Counter-1 at Time-4 | Counter-1 at Time-5  |
| Counter-ID 2 | Counter-2 at Time-0 | Counter-2 at Time-1 | Counter-2 at Time-2 | Counter-2 at Time-3 | Counter-2 at Time-4 | Counter-2 at Time-5  |

To configure the format of the report, the TAM report API is extended with a new type and attribute to declare the number of samples per report, i.e. the width of the table.

```c
sai_attr_list[0].id = SAI_TAM_REPORT_ATTR_TYPE;
sai_attr_list[0].value.u32 = SAI_TAM_REPORT_TYPE_TIMESLICE;

sai_attr_list[1].id = SAI_TAM_REPORT_ATTR_NUMBER_OF_TIMESLICES;
sai_attr_list[1].value.u32 = 6;

attr_count = 2;

sai_create_tam_report_fn(
   &sai_tam_report_obj,
   switch_id,
   attr_count,
   sai_attr_list);
```

An implementation should use atomic snapshots when possible. If not, the counters should be collected so the time interval between different snapshots is as consistent as possible across the selected counters. For example, by collecting in the same order across multiple timeslices.

### 3.0 Granular counter subscription

The TAM API previously allowed for predefined telemetry groups, like SAI_TAM_TELEMETRY_TYPE_SWITCH or SAI_TAM_TELEMETRY_TYPE_PORT. This provides extensibility to the API only to define new fixed collections.

However, there may be a need for the client to request telemetry for specific counters at runtime. For example, a user may wish to receive only a port byte counter, or a queue watermarks. With granular counter subscription, a the user may subscribe to a specific set of counters, via a list of stat enums with their associated object types.

This could be used in combination with the timeslice format, especially with very rapid intervals, to limit the streamed data to a small number of specific counters.

```c
typedef struct _sai_object_stat_id_t
{
    sai_object_type_t object_type;
    sai_stat_id_t stat_enum;
} sai_object_stat_id_t;


typedef struct _sai_object_stat_list_t
{
    uint32_t count;
    sai_object_stat_id_t *list;
} sai_object_stat_list_t;    
```

The telemetry type object is defined to allow the use of this list as an attribute.

```
/**
 * @brief List of stats to collect
 *
 * @type sai_object_stat_list_t
 * @flags CREATE_AND_SET
 * @default empty
 */
 SAI_TAM_TEL_TYPE_ATTR_OBJECT_STATS,
```

## 3.1 Configuration example

```c
sai_attr_list[0].id = SAI_TAM_TEL_TYPE_ATTR_TELEMETRY_TYPE;
sai_attr_list[0].value.u32 = SAI_TAM_TEL_TYPE_ATTR_OBJECT_STAT

sai_attr_list[1].id = SAI_TAM_TEL_TYPE_ATTR_OBJECT_STATS;
sai_attr_list[1].value.objectstatlist.count = 1;
sai_attr_list[1].value.objectstatlist.list[0].object_type = SAI_OBJECT_TYPE_INGRESS_PRIORITY_GROUP;
sai_attr_list[1].value.objectstatlist.list[0].stat_enum = SAI_INGRESS_PRIORITY_GROUP_STAT_CURR_OCCUPANCY_BYTES;

sai_attr_list[2].id = SAI_TAM_TEL_TYPE_ATTR_REPORT_ID;
sai_attr_list[2].value.oid = sai_tam_report_obj; /* Report object created earlier and reused */

attr_count = 3;
sai_create_tam_tel_type_fn(
    &sai_tam_flow_tel_type_obj,
    switch_id,
    attr_count,
    sai_attr_list);

// Example: Create TAM object and attach to monitored objects:
sai_attr_list[0].value.objlist.count = 1;
sai_attr_list[0].value.objlist.list[0] = sai_tam_telemetry_obj;

sai_attr_list[1].id = SAI_TAM_ATTR_EVENT_OBJECTS_LIST;
sai_attr_list[1].value.objlist.count = 1;
sai_attr_list[1].value.objlist.list[0] = sai_tam_event1_obj;

sai_attr_list[1].id = SAI_TAM_ATTR_TAM_BIND_POINT_TYPE_LIST;
sai_attr_list[1].value.objlist.count = 1;
sai_attr_list[1].value.objlist.list[0] = SAI_TAM_BIND_POINT_TYPE_IPG;

attr_count = 3;
sai_create_tam_fn(
    &sai_tam_obj,
    switch_id,
    attr_count,
    sai_attr_list);

sai_attr.id = SAI_INGRESS_PRIORITY_GROUP_ATTR_TAM;
sai_attr.value.oid = sai_tam_obj;

sai_set_ingress_priority_group_attribute_fn(
    sai_ipg1_obj,
    sai_attr);

sai_set_ingress_priority_group_attribute_fn(
    sai_ipg2_obj,
    sai_attr);
```
